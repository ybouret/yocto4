#include "yocto/mpa/rsa/codec.hpp"
#include "yocto/exception.hpp"


namespace yocto
{
    namespace mpa
    {
        
        namespace RSA
        {
            
            //__________________________________________________________________
            //
            // Codec
            //__________________________________________________________________
            Codec:: ~Codec() throw()
            {
            }
            
            Codec:: Codec( const Key &k ) :
            pack::q_codec(),
            key( k.clone() ),
            plain(),
            coded()
            {
            }
            
            void Codec:: reset() throw()
            {
                Q.free();
                plain.free();
                coded.free();
            }
            
            //__________________________________________________________________
            //
            // encoder
            //__________________________________________________________________
            encoder:: encoder(const Key &k ) :
            Codec(k)
            {
                
            }
            
            encoder:: ~encoder() throw()
            {
                
            }
            
            void encoder:: write( char C )
            {
                //______________________________________________________________
                //
                // say a char is coming
                //______________________________________________________________
                plain.push( true );
                //______________________________________________________________
                //
                // add some noise
                //______________________________________________________________
                plain.push( memIO::random_bit() );
                //______________________________________________________________
                //
                // write 8 bits
                //______________________________________________________________
                plain.push_full<uint8_t>(C);
                
                //______________________________________________________________
                //
                // check enough bits to write
                //______________________________________________________________
                while(plain.size()>=key->ibits)
                    emit();
            }
            
            void encoder:: emit()
            {
                assert(plain.size()>=key->ibits);
                //__________________________________________________________
                //
                // fetch a message from input bits
                //__________________________________________________________
                const mpn M = mpn::query(plain,key->ibits);
                
                //__________________________________________________________
                //
                // encode it
                //__________________________________________________________
                const mpn C = key->encode(M); assert(C<key->modulus);
                
                //__________________________________________________________
                //
                // store in output bits
                //__________________________________________________________
                C.store(coded,key->obits);
                
                //__________________________________________________________
                //
                // convert in output bytes
                //__________________________________________________________
                while(coded.size()>=8)
                    Q.push_back( coded.pop_full<uint8_t>() );
                
                
            }
            
            
            void encoder:: flush()
            {
                //______________________________________________________________
                //
                // say the end is coming
                //______________________________________________________________
                plain.push( false );
                
                //______________________________________________________________
                //
                // fill for new messages
                //______________________________________________________________
                while( 0 != (plain.size()%key->ibits) )
                    plain.push( memIO::random_bit() );
                
                //______________________________________________________________
                //
                // emit all the left message
                //______________________________________________________________
                while(plain.size()>=key->ibits)
                    emit();
                assert(0==plain.size());
                
                //______________________________________________________________
                //
                // round output bits
                //______________________________________________________________
                while( 0 != (coded.size() % 8) )
                    coded.push( memIO::random_bit() );
                
                //______________________________________________________________
                //
                // convert into bytes
                //______________________________________________________________
                while( coded.size()>=8 )
                    Q.push_back( coded.pop_full<uint8_t>() );
                assert(0==coded.size());
            }
            
            //__________________________________________________________________
            //
            // decoder
            //__________________________________________________________________
            decoder:: decoder(const Key &k ) : Codec(k)
            {
                
            }
            
            decoder:: ~decoder() throw()
            {
                
            }
            
            
            void decoder:: write(char C)
            {
                //______________________________________________________________
                //
                // fill input bits
                //______________________________________________________________
                coded.push_full<uint8_t>(C);
                
                
                
            }
            
            
            void decoder:: flush()
            {
                
            }
            
            
        }
    }
}
