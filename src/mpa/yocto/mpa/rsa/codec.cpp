#include "yocto/mpa/rsa/codec.hpp"
#include "yocto/exception.hpp"


namespace yocto
{
    namespace mpa
    {
        
        namespace RSA
        {
            
            //__________________________________________________________________
            //
            // Codec
            //__________________________________________________________________
            Codec:: ~Codec() throw()
            {
            }
            
            Codec:: Codec( const Key &k ) :
            pack::q_codec(),
            key( k.clone() ),
            I(),
            O()
            {
            }
            
            void Codec:: reset() throw()
            {
                Q.free();
                I.free();
                O.free();
            }
            
            //__________________________________________________________________
            //
            // encoder
            //__________________________________________________________________
            encoder:: encoder(const Key &k ) :
            Codec(k)
            {
                
            }
            
            encoder:: ~encoder() throw()
            {
                
            }
            
            void encoder:: write( char C )
            {
                //______________________________________________________________
                //
                // say a char is coming
                //______________________________________________________________
                I.push( true );
                //______________________________________________________________
                //
                // add some noise
                //______________________________________________________________
                I.push( memIO::random_bit() );
                //______________________________________________________________
                //
                // write 8 bits
                //______________________________________________________________
                I.push_full<uint8_t>(C);
                
                //______________________________________________________________
                //
                // check enough bits to write
                //______________________________________________________________
                if(I.size()>=key->ibits)
                    emit();
            }
            
            void encoder:: emit()
            {
                while(I.size()>=key->ibits)
                {
                    //__________________________________________________________
                    //
                    // fetch a message from input bits
                    //__________________________________________________________
                    const mpn M = mpn::query(I,key->ibits);
                    
                    //__________________________________________________________
                    //
                    // encode it
                    //__________________________________________________________
                    const mpn C = key->encode(M); assert(C<key->modulus);
                    
                    //__________________________________________________________
                    //
                    // store in output bits
                    //__________________________________________________________
                    C.store(O,key->obits);
                    
                    //__________________________________________________________
                    //
                    // convert in output bytes
                    //__________________________________________________________
                    while(O.size()>=8)
                        Q.push_back( O.pop_full<uint8_t>() );
                }
                
            }
            
            
            void encoder:: flush()
            {
                //______________________________________________________________
                //
                // say the end is coming
                //______________________________________________________________
                I.push( false );
                
                //______________________________________________________________
                //
                // fill for new messages
                //______________________________________________________________
                while( 0 != (I.size()%key->ibits) )
                    I.push( memIO::random_bit() );
                
                //______________________________________________________________
                //
                // emit all the left message
                //______________________________________________________________
                emit();
                assert(0==I.size());
                
                //______________________________________________________________
                //
                // round output bits
                //______________________________________________________________
                while( 0 != (O.size() % 8) )
                    O.push( memIO::random_bit() );
                
                //______________________________________________________________
                //
                // convert into bytes
                //______________________________________________________________
                while( O.size()>=8 )
                    Q.push_back( O.pop_full<uint8_t>() );
                assert(0==O.size());
            }
            
            //__________________________________________________________________
            //
            // decoder
            //__________________________________________________________________
            decoder:: decoder(const Key &k ) : Codec(k)
            {
                
            }
            
            decoder:: ~decoder() throw()
            {
                
            }
            
            
            void decoder:: write(char C)
            {
                //______________________________________________________________
                //
                // fill input bits
                //______________________________________________________________
                I.push_full<uint8_t>(C);
                
                //______________________________________________________________
                //
                // decode input bits into output bits
                //______________________________________________________________
                while(I.size()>=key->obits)
                {
                    const mpn C = mpn::query(I,key->obits);
                    const mpn P = key->decode(C);
                    if(P.bits()>key->ibits)
                        throw exception("RSA::decoder(corrupted input)");
                    P.store(O,key->ibits);
                }
                
                
                
                
            }
            
            
            void decoder:: flush()
            {
                
            }
            
            
        }
    }
}
